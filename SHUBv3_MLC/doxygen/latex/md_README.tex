\chapter{README}
\hypertarget{md_README}{}\label{md_README}\index{README@{README}}
{\bfseries{Machine Learning Core with STM MEMS}}

{\bfseries{Sensor LSM6\+DSOX}}

Harris Koutsourelakis

V1.\+0

14 Sep 2022

{\bfseries{Abstract}}

\begin{quote}
This work presents the methodology to develop AI-\/based applications for Internet-\/of-\/\+Things environments, such as detection of a falling object by using the machine learning core inside the STM Mems Sensor LSM6\+DSOX and the toolchain Unico, Unicleo and WEKA. \end{quote}
\hypertarget{md_README_autotoc_md23}{}\doxysection{\texorpdfstring{Table of Contents}{Table of Contents}}\label{md_README_autotoc_md23}
\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+Abstract\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}

1 \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+Equipment\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}

1.1 \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+B-\/\+L072\+Z-\/\+LRWAN1\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}

1.2 \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+X-\/\+NUCLEO-\/\+IKS01\+A3\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}

1.3 \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+STEVAL-\/\+MKI197\+V1\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}

2 \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+Hardware Synthesis\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}

2.1 \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+Connection between B-\/\+L072\+Z-\/\+LRWAN1 and X-\/\+NUCLEO-\/\+IKS01\+A3\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}

2.2 \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+Connection between X-\/\+NUCLEO-\/\+IKS01\+A3 and STEVAL-\/\+MKI197\+V1\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}

2.3 \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+LSM6\+DSOX Sensor Initialization\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}

3 \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+Firmware and Software\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}

3.1 \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+Firmware\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}

3.2 \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+Unicleo-\/\+GUI\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}

3.3 \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+Unico-\/\+GUI\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}

3.4 \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+Weka\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}

4 \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+Implementation\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}

4.1 \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+STM32\+Cube\+IDE\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}

4.2 \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+Unicleo-\/\+GUI\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}

4.3 \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+Machine Learning Core Example\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}

4.4 \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+Unico-\/\+GUI\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}

4.5 \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+Weka\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}

4.6 \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+Video Demonstration\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}

5 \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+Falling Detection Algorithm\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}

5.1 \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+Creation of Falling Detection Datasets\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}

5.2 \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+Project Equipment\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}

5.3 \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+Video Demonstration\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}

5.4 \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+Possible Real-\/\+World Use Scenarios\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}

6 \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+Falling Detection Algorithm With NUCLEO-\/\+WL55\+JCx and SHUBv3\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}

6.1 \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+Equipment\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}

6.2 \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+Decision Tree Generation\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}

6.2.1 \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+K-\/fold Cross-\/\+Validation\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}

6.2.2 \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+J48 Algorithm (also known as C4.5)\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}

6.3 \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+Performance\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}

6.4 \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+Video Demonstration\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}

7 \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+References\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\hypertarget{md_README_autotoc_md24}{}\doxysection{\texorpdfstring{{\bfseries{Equipment}}}{{\bfseries{Equipment}}}}\label{md_README_autotoc_md24}
The equipment used in this project consists of the board \href{https://www.st.com/en/evaluation-tools/b-l072z-lrwan1.html}{\texttt{ B-\/\+L072\+Z-\/\+LRWAN1}}, the \mbox{[}X-\/\+NUCLEO-\/\+IKS01\+A3 extender and the \href{https://www.st.com/en/evaluation-tools/steval-mki197v1.html}{\texttt{ STEVAL-\/\+MKI197\+V1}}. The IKS01\+A3 is the extension board that provides the DIL24 socket that the \href{https://www.st.com/en/evaluation-tools/steval-mki197v1.html}{\texttt{ MKI197\+V1}} (Machine Learning Core LSM6\+DOX) connects to in order to communicate with the board.\mbox{]}(\href{https://www.st.com/en/ecosystems/x-nucleo-iks01a3.html}{\texttt{ https\+://www.\+st.\+com/en/ecosystems/x-\/nucleo-\/iks01a3.\+html}})\hypertarget{md_README_autotoc_md25}{}\doxysubsection{\texorpdfstring{{\bfseries{B-\/\+L072\+Z-\/\+LRWAN1}}}{{\bfseries{B-\/\+L072\+Z-\/\+LRWAN1}}}}\label{md_README_autotoc_md25}
The {\bfseries{B-\/\+L072\+Z-\/\+LRWAN1}}\textbackslash{}\mbox{[}1\textbackslash{}\mbox{]} board was chosen specifically for this project due to its portability, Lo\+Ra\+Wan Connectivity and low battery consumption.

\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\href{https://www.st.com/en/evaluation-tools/b-l072z-lrwan1.html}{\texttt{ B-\/\+L072\+Z-\/\+LRWAN1}} ~\newline
\hypertarget{md_README_autotoc_md26}{}\doxysubsection{\texorpdfstring{{\bfseries{X-\/\+NUCLEO-\/\+IKS01\+A3}}}{{\bfseries{X-\/\+NUCLEO-\/\+IKS01\+A3}}}}\label{md_README_autotoc_md26}
The \href{https://www.st.com/en/ecosystems/x-nucleo-iks01a3.html}{\texttt{ X-\/\+NUCLEO-\/\+IKS01\+A3}}\textbackslash{}\mbox{[}2\textbackslash{}\mbox{]} is a is a motion MEMS and environmental sensor evaluation board system. It is compatible with the Arduino UNO R3 connector layout and features the LSM6\+DSO 3-\/axis accelerometer + 3-\/axis gyroscope, the LIS2\+MDL 3-\/axis magnetometer, the LIS2\+DW12 3-\/axis accelerometer, the HTS221 humidity and temperature sensor, the LPS22\+HH pressure sensor, and the STTS751 temperature sensor.

The X-\/\+NUCLEO-\/\+IKS01\+A3 interfaces with the STM32 microcontroller via the I²C pin, and it is possible to change the default I²C port.

\href{https://www.st.com/en/ecosystems/x-nucleo-iks01a3.html}{\texttt{ \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+X-\/\+NUCLEO-\/\+IKS01\+A3 \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}}

\hypertarget{md_README_autotoc_md27}{}\doxysubsection{\texorpdfstring{{\bfseries{STEVAL-\/\+MKI197\+V1}}}{{\bfseries{STEVAL-\/\+MKI197\+V1}}}}\label{md_README_autotoc_md27}
The \href{https://www.st.com/en/evaluation-tools/steval-mki197v1.html}{\texttt{ STEVAL-\/\+MKI197\+V1}}\textbackslash{}\mbox{[}3\textbackslash{}\mbox{]} is an adapter board designed to facilitate the evaluation of MEMS devices in the LSM6\+DSO product family. The board offers an effective solution for fast system prototyping and device evaluation directly within the user’s own application.

STEVAL-\/\+MKI197\+V1

\hypertarget{md_README_autotoc_md28}{}\doxysection{\texorpdfstring{{\bfseries{Hardware Synthesis}}}{{\bfseries{Hardware Synthesis}}}}\label{md_README_autotoc_md28}
\hypertarget{md_README_autotoc_md29}{}\doxysubsection{\texorpdfstring{{\bfseries{Connection between B-\/\+L072\+Z-\/\+LRWAN1 and X-\/\+NUCLEO-\/\+IKS01\+A3}}}{{\bfseries{Connection between B-\/\+L072\+Z-\/\+LRWAN1 and X-\/\+NUCLEO-\/\+IKS01\+A3}}}}\label{md_README_autotoc_md29}
First, the {\bfseries{X-\/\+NUCLEO-\/\+IKS01\+A3}} needs to be connected to the Arduino R3 pinouts of {\bfseries{B-\/\+L072\+Z-\/\+LRWAN1}}. This gives the option to connect the {\bfseries{STEVAL-\/\+MKI197\+V1}} to the DIL24 socket on top of the Nucleo extender.

\hypertarget{md_README_autotoc_md30}{}\doxysubsection{\texorpdfstring{{\bfseries{Connection between X-\/\+NUCLEO-\/\+IKS01\+A3 and STEVAL-\/\+MKI197\+V1}}}{{\bfseries{Connection between X-\/\+NUCLEO-\/\+IKS01\+A3 and STEVAL-\/\+MKI197\+V1}}}}\label{md_README_autotoc_md30}
Next, the {\bfseries{STEVAL-\/\+MKI197\+V1}} must be connected on the {\bfseries{DIL24 Socket}} of the {\bfseries{X-\/\+NUCLEO-\/\+IKS01\+A3}}.

{\bfseries{IMPORTANT}}\+: Make sure the ST Logo on BOTH the extender and the adapter are aligned, otherwise the adapter will overheat and most likely lead to short-\/circuit.

\hypertarget{md_README_autotoc_md31}{}\doxysubsection{\texorpdfstring{{\bfseries{LSM6\+DSOX Sensor Initialization}}}{{\bfseries{LSM6\+DSOX Sensor Initialization}}}}\label{md_README_autotoc_md31}
The {\bfseries{LSM6\+DSOX}} (Machine Learning Core) sensor on the {\bfseries{MKI197\+V1}} does not communicate out of the box with the {\bfseries{IKS01\+A3}}. The {\bfseries{LSM6\+DSOX}} sensor starts in {\bfseries{I3C}}\textbackslash{}\mbox{[}4\textbackslash{}\mbox{]} mode (also known as Sense\+Wire) because of a level shifter on the {\bfseries{IKS01\+A3}} that keeps the INT1 of the {\bfseries{LSM6\+DSOX}} high, this results to {\bfseries{I3C}} initialization by default (as described in the Datasheet).

The only solution that was found was to bypass the INT1 and route the INT2 in its place. That can be done by connecting the A5 pin of the IKS01\+A3 to GND with a wire and also change the JP6 Jumper from the default 5-\/6 to 13-\/14. The change of the Jumper supposedly sets the M\+\_\+\+INT2\+\_\+0 on pin D2, in case a change needs to be made in the schematic.

{\bfseries{After these changes, the LSM6\+DSOX sensor will be enabled.}}

\hypertarget{md_README_autotoc_md32}{}\doxysection{\texorpdfstring{{\bfseries{Firmware and Software}}}{{\bfseries{Firmware and Software}}}}\label{md_README_autotoc_md32}
\hypertarget{md_README_autotoc_md33}{}\doxysubsection{\texorpdfstring{{\bfseries{Firmware}}}{{\bfseries{Firmware}}}}\label{md_README_autotoc_md33}
The Firmware that was used is \href{https://github.com/STMicroelectronics/X-CUBE-MEMS1}{\texttt{ the X-\/\+CUBE-\/\+MEMS1 Firmware Package}}\textbackslash{}\mbox{[}5\textbackslash{}\mbox{]}.

The X-\/\+CUBE-\/\+MEMS1 expansion software package for STM32\+Cube runs on the STM32 and includes drivers that recognize the sensors and collect temperature, humidity, pressure, and motion data. The expansion is built on STM32\+Cube software technology to ease portability across different STM32 microcontrollers. The software comes with a sample implementation of the drivers running on the X-\/\+NUCLEO-\/\+IKS01\+A2/\+X-\/\+NUCLEO-\/\+IKS01\+A3/\+X-\/\+NUCLEO-\/\+IKS02\+A1 expansion boards connected to a featured STM32 Nucleo development board. The software is also available on Git\+Hub, where the users can signal bugs and propose new ideas through Issues and Pull requests tabs.

{\bfseries{Note}}\+: Inside the repository folder {\bfseries{Projects}}, the only available options are Nucleo-\/based projects. The ones that were tested though, work just fine with other ST boards, since one of the {\bfseries{Extenders}} that are compatible ({\bfseries{IKS01\+A1/\+IKS01\+A2/\+IKS01\+A3}}), are used.\hypertarget{md_README_autotoc_md34}{}\doxysubsection{\texorpdfstring{\href{https://www.st.com/en/development-tools/unicleo-gui.html}{\texttt{ \texorpdfstring{$<$}{<}span id="{}\+\_\+\+Toc119493241"{} class="{}anchor"{}\texorpdfstring{$>$}{>}{\bfseries{Unicleo-\/\+GUI}}}}}{\href{https://www.st.com/en/development-tools/unicleo-gui.html}{\texttt{ \texorpdfstring{$<$}{<}span id="{}\+\_\+\+Toc119493241"{} class="{}anchor"{}\texorpdfstring{$>$}{>}{\bfseries{Unicleo-\/\+GUI}}}}}}\label{md_README_autotoc_md34}
{\bfseries{Unicleo-\/\+GUI}}\textbackslash{}\mbox{[}6\textbackslash{}\mbox{]} is a graphical user interface (GUI) for the X-\/\+CUBE-\/\+MEMS1 and X-\/\+CUBE-\/\+MEMS-\/\+XT1 software expansions and STM32 Nucleo expansion boards (X-\/\+NUCLEO-\/\+IKS01\+A1, X-\/\+NUCLEO-\/\+IKS01\+A2, X-\/\+NUCLEO-\/\+IKS01\+A3 and X-\/\+NUCLEO-\/\+IKS02\+A1). The main objective of this application is to demonstrate the functionality of ST sensors and algorithms.

Unicleo-\/\+GUI is able to cooperate with firmware created by Algo\+Builder application and display data coming from the running firmware.

The application is also able to establish Bluetooth connection with BLE connectivity-\/equipped devices such as Sensor\+Tile (STEVAL-\/ STLKT01\+V1), Blue\+Coin (STEVAL-\/\+BCNKT01\+V1), and STM32 Nucleo with X-\/\+NUCLEO-\/\+IDB05\+A1 expansion board, Blue\+Tile (STEVAL-\/\+BCN002\+V1B) or WESU1 (STEVAL-\/\+WESU1) and read data from various device characteristics. The supported firmware for these devices can be found at FP-\/\+SNS-\/\+ALLMEMS1, FP-\/\+SNS-\/\+ALLMEMS2, FP-\/\+SNS-\/\+MOTENV1, FP-\/\+SNS-\/\+MOTENVWB1, STSW-\/ BLUETILE-\/\+DK and STSW-\/\+WESU1.\hypertarget{md_README_autotoc_md35}{}\doxysubsection{\texorpdfstring{\href{https://www.st.com/en/development-tools/unico-gui.html}{\texttt{ \texorpdfstring{$<$}{<}span id="{}\+\_\+\+Toc119493242"{} class="{}anchor"{}\texorpdfstring{$>$}{>}{\bfseries{Unico-\/\+GUI}}}}}{\href{https://www.st.com/en/development-tools/unico-gui.html}{\texttt{ \texorpdfstring{$<$}{<}span id="{}\+\_\+\+Toc119493242"{} class="{}anchor"{}\texorpdfstring{$>$}{>}{\bfseries{Unico-\/\+GUI}}}}}}\label{md_README_autotoc_md35}
{\bfseries{Unico-\/\+GUI}}\textbackslash{}\mbox{[}7\textbackslash{}\mbox{]} is a comprehensive software package for the evaluation boards of all MEMS sensors available in ST’s product portfolio (accelerometers, gyroscopes, magnetometers and environmental sensors).

The software is a cross-\/platform graphical user interface interacting with STEVAL-\/\+MKI109\+V3 (Professional MEMS tool) which is the motherboard compatible with all ST MEMS adapter boards. It is also possible to run UNICO offline (without the motherboard) for generating configurations of advanced features like the Machine Learning Core, Finite State Machine, and pedometer.

The platform allows quick and easy setup of the sensors, as well as the complete configuration of all the registers and advanced features (such as the Machine Learning Core, Finite State Machine, pedometer, etc.) embedded in the digital output devices. The software visualizes the output of the sensors in both graphical and numeric format, and allows the user to save or generally manage data coming from the device.

Examples of tools which support the advanced features are the following\+: FIFO tool that allows the user to buffer data with a high level of flexibility and burst the significant data out when needed; Finite State Machine tool that allows the user to configure the state machines, test their functionality and validate the program; Machine Learning Core tool that allows the user to configure a machine learning core starting from the management of data patterns and labeling to setting and generating the configuration file to run the algorithm; FFT tool that allows visualizing the Fast Fourier Transform of the output data; Pedometer tool that allows the user to configure and test the pedometer embedded in the device including an offline post-\/processing analysis;\hypertarget{md_README_autotoc_md36}{}\doxysubsection{\texorpdfstring{\href{https://www.cs.waikato.ac.nz/ml/index.html}{\texttt{ \texorpdfstring{$<$}{<}span id="{}\+\_\+\+Toc119493243"{} class="{}anchor"{}\texorpdfstring{$>$}{>}{\bfseries{Weka}}}}}{\href{https://www.cs.waikato.ac.nz/ml/index.html}{\texttt{ \texorpdfstring{$<$}{<}span id="{}\+\_\+\+Toc119493243"{} class="{}anchor"{}\texorpdfstring{$>$}{>}{\bfseries{Weka}}}}}}\label{md_README_autotoc_md36}
{\bfseries{Weka}}\textbackslash{}\mbox{[}8\textbackslash{}\mbox{]} contains a collection of visualization tools and algorithms for \href{https://en.wikipedia.org/wiki/Data_analysis}{\texttt{ \uline{data anal}y\uline{sis}}} and \href{https://en.wikipedia.org/wiki/Predictive_modeling}{\texttt{ p\uline{redictive modeling}}}, together with graphical user interfaces for easy access to these functions.\href{https://en.wikipedia.org/wiki/Weka_(machine_learning)\#cite_note-\%3A0-1}{\texttt{ \mbox{[}}}\uline{1\mbox{]}}. Advantages of Weka include\+:


\begin{DoxyItemize}
\item Portability, since it is fully implemented in the \mbox{[}\uline{Java} p\uline{rogramming language}\mbox{]}(\href{https://en.wikipedia.org/wiki/Java_programming_language}{\texttt{ https\+://en.\+wikipedia.\+org/wiki/\+Java\+\_\+programming\+\_\+language}}) and thus runs on almost any modern computing platform.
\item A comprehensive collection of data preprocessing and modeling techniques.
\item Ease of use due to its graphical user interfaces.
\end{DoxyItemize}

Weka supports several standard \href{https://en.wikipedia.org/wiki/Data_mining}{\texttt{ \uline{data minin}g}} tasks, more specifically, data preprocessing, \href{https://en.wikipedia.org/wiki/Data_clustering}{\texttt{ \uline{clusterin}g}}, \href{https://en.wikipedia.org/wiki/Statistical_classification}{\texttt{ \uline{classification}}}, \href{https://en.wikipedia.org/wiki/Regression_analysis}{\texttt{ \uline{re}g\uline{ression}}}, \href{https://en.wikipedia.org/wiki/Data_visualization}{\texttt{ \uline{visualization}}}, and \href{https://en.wikipedia.org/wiki/Feature_selection}{\texttt{ \uline{feature selection}}}.

Input to Weka is expected to be formatted according the Attribute-\/\+Relational File Format and with the filename bearing the \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}.arff\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*} extension. All of Weka\textquotesingle{}s techniques are predicated on the assumption that the data is available as one flat file or relation, where each data point is described by a fixed number of attributes (normally, numeric or nominal attributes, but some other attribute types are also supported). Weka provides access to \href{https://en.wikipedia.org/wiki/SQL}{\texttt{ \uline{SQ}}}L \href{https://en.wikipedia.org/wiki/Database}{\texttt{ databases}} using \mbox{[}\uline{Java Database Connectivit}y\mbox{]}(\href{https://en.wikipedia.org/wiki/Java_Database_Connectivity}{\texttt{ https\+://en.\+wikipedia.\+org/wiki/\+Java\+\_\+\+Database\+\_\+\+Connectivity}}) and can process the result returned by a database query. Weka provides access to \href{https://en.wikipedia.org/wiki/Deep_learning}{\texttt{ \uline{dee}p \uline{learning}}} with \href{https://en.wikipedia.org/wiki/Deeplearning4j}{\texttt{ \uline{Dee}p\uline{learning4j}}}.\href{https://en.wikipedia.org/wiki/Weka_(machine_learning)\#cite_note-4}{\texttt{ \mbox{[}}}\uline{4\mbox{]}} It is not capable of multi-\/relational data mining, but there is separate software for converting a collection of linked database tables into a single table that is suitable for processing using Weka.\href{https://en.wikipedia.org/wiki/Weka_(machine_learning)\#cite_note-5}{\texttt{ \mbox{[}}}\uline{5\mbox{]}} Another important area that is currently not covered by the algorithms included in the Weka distribution is sequence modeling.\hypertarget{md_README_autotoc_md37}{}\doxysection{\texorpdfstring{Implementation}{Implementation}}\label{md_README_autotoc_md37}
\hypertarget{md_README_autotoc_md38}{}\doxysubsection{\texorpdfstring{{\bfseries{STM32\+Cube\+IDE}}}{{\bfseries{STM32\+Cube\+IDE}}}}\label{md_README_autotoc_md38}
First, the program needs to be flashed on the board. This needs to be done with {\bfseries{STM32\+Cube\+IDE}}.\hypertarget{md_README_autotoc_md39}{}\doxysubsection{\texorpdfstring{{\bfseries{Unicleo-\/\+GUI}}}{{\bfseries{Unicleo-\/\+GUI}}}}\label{md_README_autotoc_md39}
After the program was flashed to the board, the sensors are initialized and ready to be used.

This is the interface of {\bfseries{Unicleo}}. If the board is connected via USB (ST Link) then the Serial Port

should be automatically selected, mine for example is COM5. \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+S\texorpdfstring{$\ast$}{*}elect Connect\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}.

The sensors list will pop up and show all available sensors. Choose the {\bfseries{LSM6\+DSOX (DIL24)}}.

{\bfseries{Note}} {\bfseries{that}} there is also another sensor named LSM6\+DSO, that is the exact same sensor, but on the extender IKS01\+A3 and does not contain the Machine Learning Core.

\begin{quote}
 \end{quote}
After {\bfseries{Apply}} has been selected, the following window will pop up. It shows the sensors of the IKS01\+A3 and the MKI197\+V1 along with their locations on the board\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}.\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}

On the left the option for the visualization of the available sensors can be seen.

If {\itshape {\bfseries{MLC}}} is chosen from the left, the user will be greeted by the following window. On the first block, named {\itshape {\bfseries{Sensor Configuration}}}, a custom {\itshape {\bfseries{.ucf}}} dataset can be loaded. Bellow that are some {\itshape {\bfseries{Example Algorithms}}}, that, if chosen, they will be loaded and cording to the motion of the sensor, a different value will be shown on the {\itshape {\bfseries{MLC Source Registers}}} bellow.

The values will be displayed on the blocks on the right of {\itshape {\bfseries{MLC0\+\_\+\+SRC}}}.\hypertarget{md_README_autotoc_md40}{}\doxysubsection{\texorpdfstring{{\bfseries{Machine Learning Core Example}}}{{\bfseries{Machine Learning Core Example}}}}\label{md_README_autotoc_md40}
For example, here are the specifics of the {\itshape {\bfseries{Activity Recognition (Wrist)}}} algorithm.

According to the documentation of the algorithm\+:


\begin{DoxyItemize}
\item {\bfseries{1 = Stationary/\+Other}}
\item {\bfseries{4 = Walking/\+Fast Walking}}
\item {\bfseries{8 = Jogging/\+Running}}
\end{DoxyItemize}

\texorpdfstring{$\ast$}{*}

Before an algorithm can be selected, {\itshape {\bfseries{Start}}} must be selected on the main window, to activate the sensor. After that, the sensor will begin sending feedback.



Now, instead of using one of the example algorithms, a custom {\itshape {\bfseries{.ucf}}} file will be created and used to show the configurations that need to be set. To do that, data must be logged into a dataset based on each action that one wants to add to the Decision Tree. The log will be created in Unicleo (in {\itshape {\bfseries{.txt/ .csv}}} format) and then {\itshape {\bfseries{Unico}}} will be used to create the {\itshape {\bfseries{.ucf}}} file. Then the {\itshape {\bfseries{.ucf}}} file will be loaded to {\itshape {\bfseries{Weka}}} to create {\itshape {\bfseries{Decision Tree}}} and after that it will be loaded back to {\itshape {\bfseries{Unico}}}.

{\itshape In order to log the data, the {\bfseries{Datalog}} option needs to be chosen on the left of the main window. Next choose the sensors that you want to log into a file from both {\bfseries{Data}} and {\bfseries{Datalog period source}} ad set a file for said activity.}

\texorpdfstring{$\ast$}{*}\+Here, motions will be monitored for approximately 1 minute and saved in a dataset file {\bfseries{karate.\+csv}}. ~\newline


The same steps will be followed for the dataset {\itshape {\bfseries{boxing.\+csv .}}}

\hypertarget{md_README_autotoc_md41}{}\doxysubsection{\texorpdfstring{{\bfseries{Unico-\/\+GUI}}}{{\bfseries{Unico-\/\+GUI}}}}\label{md_README_autotoc_md41}
Now {\itshape {\bfseries{Unico}}} needs to be used in order to create a file that can be read by {\itshape {\bfseries{Weka}}}.

Since Unico cannot be used with the shield {\itshape {\bfseries{IKS01\+A3}}}, it will have to be used in offline mode. That means that it will not connect with the board, but the datasets will be able to be loaded in order to extract an {\itshape {\bfseries{.arff}}} file.

Select in the {\bfseries{i\+Nemo Inertial Modules}} the {\itshape {\bfseries{STEVAL-\/\+MKI197\+V1 (LSM6\+DSOX)}}} sensor and deselect the {\itshape {\bfseries{Communication with the motherboard}}} option. Then click on {\itshape {\bfseries{Select Device}}}.

After the main window shows up, select {\itshape {\bfseries{MLC}}} on the left and the {\itshape {\bfseries{Machine Learning Core}}} \textbackslash{}\mbox{[}9\textbackslash{}\mbox{]} window will open.

Now each one of the datasets will be loaded and set the {\itshape {\bfseries{Class Label}}} as {\itshape {\bfseries{boxing}}} for the {\bfseries{Boxing}} Dataset and {\bfseries{Karate}} for the Karate Dataset.



Then, the {\itshape {\bfseries{Configuration}}} Tab must be selected. Here are the options that were given to the {\itshape {\bfseries{Decision Tree.}}}

The chosen options were all the {\itshape {\bfseries{Signed}}} options {\itshape {\bfseries{ACC\+\_\+X, ACC\+\_\+Y, ACC\+\_\+Z, GY\+\_\+X, GY\+\_\+Z}}} for the {\itshape {\bfseries{Mean\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}, {\bfseries{Variance}}, {\bfseries{Energy}} and {\bfseries{Peak}} {\bfseries{to}} \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+Peak}}} features.





Save the file as \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}.arff\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*} and choose the desired output values of the {\bfseries{Decision Tree}}.


\begin{DoxyItemize}
\item {\bfseries{1}} was set for {\bfseries{Karate}} and {\bfseries{2}} for {\bfseries{Boxing}}.
\end{DoxyItemize}

\hypertarget{md_README_autotoc_md42}{}\doxysubsection{\texorpdfstring{{\bfseries{Weka}}}{{\bfseries{Weka}}}}\label{md_README_autotoc_md42}
Open {\itshape {\bfseries{Weka}}} {\itshape {\bfseries{Explorer}}} and load the {\bfseries{sports.\+arff}} file that was created above\+:

Select the {\itshape {\bfseries{Classify Tab}}} and then {\itshape {\bfseries{Choose}}} on the {\itshape {\bfseries{Classifier\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*} \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+Block}}} and select the {\itshape {\bfseries{J48}}} in the tree section. The {\itshape {\bfseries{Cross-\/\+Validation Folds}}} option was set on 10, as default, since it gives an approximate 98\% result.



The {\itshape {\bfseries{Decision Tree}}} has been generated, but in order to load it into {\itshape {\bfseries{Unico}}} to create the {\itshape {\bfseries{.ucf}}} file, the selected text, as seen in the image below ({\itshape {\bfseries{The tree itself}}}), needs to be copied and pasted into a {\itshape {\bfseries{.txt}}} file.



And to see the {\itshape {\bfseries{Decision Tree}}}, right click on the {\itshape {\bfseries{Result List}}} and select {\itshape {\bfseries{Visualize Tree}}}.



Now the \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}.txt\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*} file can be loaded into the {\itshape {\bfseries{Unico}}} window that was left intact a while ago.

And save the file as {\itshape {\bfseries{sports.\+ucf}}}.

 Now the {\bfseries{sports.\+ucf}} file can be loaded into {\bfseries{Unicleo}} in the {\bfseries{MLC}} (Machine Learning Core) option.



Here the changes can be seen as the value changes to {\bfseries{0x01}} in {\itshape {\bfseries{MLC0\+\_\+\+SRC}}} when the board mimics the action for {\bfseries{Karate}} .



And here {\itshape {\bfseries{MLC0\+\_\+\+SRC}}} changes to {\itshape {\bfseries{2}}} when the board mimics the action for {\bfseries{Boxing}}.

\hypertarget{md_README_autotoc_md43}{}\doxysubsection{\texorpdfstring{{\bfseries{Video Demonstration}}}{{\bfseries{Video Demonstration}}}}\label{md_README_autotoc_md43}
\href{https://www.youtube.com/watch?v=m6ylfVGBezo}{\texttt{ Here is a video demonstration of the}} {\itshape {\bfseries{LSM6\+DSOX}}} sensor changing value from {\itshape 1} to {\itshape 2} when it recognizes the different actions.

\begin{quote}
\href{https://www.youtube.com/watch?v=m6ylfVGBezo}{\texttt{ \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\uline{Machine Learning Core LSM6\+DSOX Demonstration} \textbackslash{}\texorpdfstring{$\vert$}{|}\textbackslash{}\texorpdfstring{$\vert$}{|} \uline{ISCA Lab}\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}} \textbackslash{}\mbox{[}10\textbackslash{}\mbox{]} \end{quote}
\hypertarget{md_README_autotoc_md44}{}\doxysection{\texorpdfstring{{\bfseries{Falling Detection Algorithm}}}{{\bfseries{Falling Detection Algorithm}}}}\label{md_README_autotoc_md44}
\begin{quote}
This example is made for the use-\/case of detecting the Fall of the device from {\bfseries{Low}} or {\bfseries{High altitude}}. It demonstrates the change on the registers of the Machine Learning Core of Unicleo when the board is free-\/falling from both a low and high altitude.

In order to create the datasets for both falls, a scenario was created for logging the Data for each case. \end{quote}
\hypertarget{md_README_autotoc_md45}{}\doxysubsection{\texorpdfstring{{\bfseries{Creation of Falling Detection Datasets}}}{{\bfseries{Creation of Falling Detection Datasets}}}}\label{md_README_autotoc_md45}
\begin{quote}
{\bfseries{Low and High Altitude Fall}}

For both the {\bfseries{Low}} and {\bfseries{High}} altitude fall, 2 datasets were created with the board mimicking each fall, in a safe environment, from a height of approximately 90 centimeters for the {\bfseries{Low}} fall and approximately 2.\+5 meters for the {\bfseries{High}} fall.

For this scenario, the mechanism that was created consisted of a small rubber rope attached to a thin rope, used to avoid damage from the force of the velocity, whereas the rope was used to simulate the fall by hand.

Logs were taken from each scenario and then loaded into the same Decision Tree in order to have a single configuration for detecting both Falls at the same time.

In the video shown below, the changes of the registers may not be exact at times (changing from Low to High when falling) and that is because of the bounce of the board due to the rubber that was used to simulate a safe Fall.

Since the algorithm detects the data mostly from the accelerometer, when falling it may detect a greater value, but when the rubber bounces back it simulates the velocity of a Low altitude fall ,and so, it detects it as such. In a real-\/world scenario, where the board is not in a safe environment, the fall would be one-\/way and the board wouldn\textquotesingle{}t bounce, since it would most likely not be attached to anything, except maybe a cable.

In that scenario, the algorithm would detect only one Fall, and the prediction would be more precise.

Although, as most uses of a Machine Learning algorithm, many datasets need to be logged and merged for either the {\bfseries{IDLE}} state of the board or the {\bfseries{Falling Detection}}. This will lead to a more precise algorithm with a variety of predictions and broader spectrum of detections for different scenarios, angles and falls. \end{quote}
\hypertarget{md_README_autotoc_md46}{}\doxysubsection{\texorpdfstring{{\bfseries{Project Equipment}}}{{\bfseries{Project Equipment}}}}\label{md_README_autotoc_md46}
\begin{quote}
\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\uline{ ~\newline
 }\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*} ~\newline
 \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*} ~\newline
 \end{quote}
\begin{quote}
\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*} \end{quote}
\hypertarget{md_README_autotoc_md47}{}\doxysubsection{\texorpdfstring{{\bfseries{Video Demonstration}}}{{\bfseries{Video Demonstration}}}}\label{md_README_autotoc_md47}
This video demonstrates the different fall detections that the Machine Learning Core predicts from the output of the {\bfseries{Accelerometer}} and {\bfseries{Gyroscope}} of the {\bfseries{LSM6\+DSOX}} Sensor.

MLC Source Register {\itshape {\bfseries{0x70 MLC\+\_\+\+SRC}}} values in Unicleo\+:


\begin{DoxyItemize}
\item {\bfseries{0x01 -\/\texorpdfstring{$>$}{>}}} Value for the board being {\bfseries{IDLE}}
\item {\bfseries{0x04 -\/\texorpdfstring{$>$}{>}}} Value for the board falling from a {\bfseries{Low Altitude}}
\item {\bfseries{0x08 -\/\texorpdfstring{$>$}{>}}} Value for the board falling from a \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+High Altitude ~\newline

\end{DoxyItemize}

\mbox{[}{\bfseries{Falling Detection with Machine Learning Core STM MEMS Sensor LSM6\+DSOX $|$$|$ ISCA Lab}} \mbox{[}11\mbox{]}\mbox{]}(\textbackslash{}l)

\mbox{[}\mbox{]}(\textbackslash{}l)\hypertarget{md_README_autotoc_md48}{}\doxysubsection{\texorpdfstring{{\bfseries{Possible Real-\/\+World Use Scenarios}}}{{\bfseries{Possible Real-\/\+World Use Scenarios}}}}\label{md_README_autotoc_md48}
A possible scenario of such a use case, such as the one shown above, would be the use of a device with capabilities of {\bfseries{Bluetooth}} connectivity.

Such a scenario would prove to be a more efficient solution to provide wireless data of a device in a monitoring database or simple real-\/time feedback to a computer.

The device that was available for this demo did not have {\bfseries{Bluetooth}} connectivity and so such a scenario was not recorded, but would bare the same results.

For example, both {\bfseries{Unico}} and {\bfseries{Unicleo}} have an option to enable {\bfseries{Bluetooth}} via their GUI interface. After that, the scenario of logging the data in a remote computer/database could be explored, in the future, for providing information of devices in case of their required position is compromised.\hypertarget{md_README_autotoc_md49}{}\doxysection{\texorpdfstring{{\bfseries{Falling Detection Algorithm With NUCLEO-\/\+WL55\+JCx and SHUBv3}}}{{\bfseries{Falling Detection Algorithm With NUCLEO-\/\+WL55\+JCx and SHUBv3}}}}\label{md_README_autotoc_md49}
This section covers the demonstration of a real use-\/case scenario for the Falling Detection Algorithm that was described previously. The microcontroller that was used is the {\bfseries{NUCLEO-\/\+WL55\+JCx}}, in addition with the {\bfseries{Sensor Hub v3}} ({\bfseries{SHUBv3}}) and on top of that is connected the {\bfseries{MKI197v1}} adapter board that uses the {\bfseries{LSM6\+DSOX}} sensor to detect any movement of the board and provide output based on the dataset that was given to it.

In contrary with the previous demonstration, this board is not in the supported devices of the {\bfseries{X-\/\+NUCLEO-\/\+MEMS1}} package, and thus a custom firmware needed to be developed, to enable communication with the {\bfseries{SHUBv3}} and the {\bfseries{MKI197v1}} adapter board.

To enable the {\bfseries{Machine Learning Core}} in this project, the LSM6\+DSOX had to be included in the project manually, along with the {\bfseries{MLC}} option, provided by ST in their \href{https://github.com/STMicroelectronics/STMems_Standard_C_drivers/blob/master/lsm6dsox_STdC/examples/lsm6dsox_mlc.c}{\texttt{ Git\+Hub}} repository.

In order to be able to monitor and log the data for the decision tree, a different firmware was developed, that enabled the {\bfseries{Unicleo-\/\+GUI}} application and allowed the Data\+Log of the simulation data.

The steps that were followed were exactly the same as shown in the sections 4.\+1 -\/ 4.\+5, with the exception that the .ucf file was converted into a header (.h) file and was used in the firmware. That way the output of the {\bfseries{MLC}} option was based registers that were given when the Decision Tree was created.\hypertarget{md_README_autotoc_md50}{}\doxysubsection{\texorpdfstring{{\bfseries{Equipment}}}{{\bfseries{Equipment}}}}\label{md_README_autotoc_md50}

\begin{DoxyItemize}
\item WL55\+JCx (x = 1 or 2)
\end{DoxyItemize}




\begin{DoxyItemize}
\item SHUBv3
\end{DoxyItemize}




\begin{DoxyItemize}
\item WL55\+JCx + Sensor\+Hub\+V3 + MKI197v1
\end{DoxyItemize}

\hypertarget{md_README_autotoc_md51}{}\doxysubsection{\texorpdfstring{{\bfseries{Decision Tree Generation}}}{{\bfseries{Decision Tree Generation}}}}\label{md_README_autotoc_md51}
The decision tree was generated based on the datasets that were logged for this project, which include\+:


\begin{DoxyEnumerate}
\item {\bfseries{Idle Position}}
\item {\bfseries{Low Fall Detection}}
\item {\bfseries{High Fall Detection}}
\end{DoxyEnumerate}

The tree was generated with WEKA, using {\bfseries{10-\/Fold Cross-\/\+Validation}} and the {\bfseries{J48}} algorithm.\hypertarget{md_README_autotoc_md52}{}\doxysubsubsection{\texorpdfstring{{\bfseries{K-\/fold Cross-\/\+Validation}}}{{\bfseries{K-\/fold Cross-\/\+Validation}}}}\label{md_README_autotoc_md52}
Cross validation is one of the techniques used to test the effectiveness of machine learning models and avoid overfitting. It is a re-\/sampling procedure used to evaluate a model, and with the option of 5 or 10 folds (e.\+g., 10-\/fold Cross-\/\+Validation), the procedure can be executed without using excessive computation sources in order to train the model.

With K-\/fold Cross-\/\+Validation we divide the data set into k-\/subsets and the procedure is repeated k-\/times. A training set is created, which consists of k-\/1 subsets and a testing set consisting of the remaining subsets.

For example, in 10-\/fold Cross-\/\+Validation, the procedure would perform a total number of ten times, reserving 9/10 parts for training and the remaining 1/10\textsuperscript{th} for testing, each time reserving a different tenth for testing.\hypertarget{md_README_autotoc_md53}{}\doxysubsubsection{\texorpdfstring{{\bfseries{J48 Algorithm (also known as C4.\+5)}}}{{\bfseries{J48 Algorithm (also known as C4.\+5)}}}}\label{md_README_autotoc_md53}
The C4.\+5 algorithm for building decision trees is implemented in Weka as a classifier ~\newline
 called J48. The decision trees from this algorithm are generated using the concept of {\bfseries{information entropy}} and can be used for {\bfseries{classification}}.


\begin{DoxyItemize}
\item {\bfseries{Information entropy}} is a measure of how much information there is in some specific data. It isn\textquotesingle{}t the length of the data, but the actual amount of information it contains.
\end{DoxyItemize}

For example, {\bfseries{one text file could contain “\+Apples are red.\+” and another text file could contain “\+Apples are red.}} {\bfseries{Apples are red.}}


\begin{DoxyItemize}
\item {\bfseries{Classification}} refers to a supervised learning concept which basically categorizes a set of data into classes.
\end{DoxyItemize}

Classifiers, like filters, are organized in a hierarchy\+: J48 has the full name ~\newline
 weka.\+classifiers.\+trees.\+J48. The classifier is shown in the text box next to the Choose ~\newline
 button\+: It reads J48 –C 0.\+25 –M 2. This text gives the default parameter settings for this ~\newline
 classifier. ~\newline
 C4.\+5 has several parameters, by the default visualization (when you invoke the ~\newline
 classifier) only shows –c ie. Confidence value (default 25\%)\+: lower values incur heavier ~\newline
 pruning and -\/­‐M ie. Minimum number of instances in the two most popular branches ~\newline
 (default 2). The full set of J48 parameter settings are explained here\+: ~\newline
 \href{http://weka.sourceforge.net/doc.dev/weka/classifiers/trees/J48.html\%20}{\texttt{ http\+://weka.\+sourceforge.\+net/doc.\+dev/weka/classifiers/trees/\+J48.\+html}} \hypertarget{md_README_autotoc_md54}{}\doxysubsection{\texorpdfstring{{\bfseries{Performance}}}{{\bfseries{Performance}}}}\label{md_README_autotoc_md54}
For the configuration that was given for this decision tree, the following test summary was given by the WEKA toolchain\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Correctly Classified Instances}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ 51   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ 80.\+9524 \%    }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Correctly Classified Instances}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ 51   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ 80.\+9524 \%    }\\\cline{1-3}
\endhead
{\bfseries{Incorrectly Classified Instances}}   &12   &19.\+0476 \%    \\\cline{1-3}
{\bfseries{Kappa statistic}}   &0.\+7056   &\\\cline{1-3}
{\bfseries{Mean absolute error}}   &0.\+1263   &\\\cline{1-3}
{\bfseries{Root mean squared error}}   &0.\+3398   &\\\cline{1-3}
{\bfseries{Relative absolute error}}   &29.\+1923 \%   &\\\cline{1-3}
{\bfseries{Root relative squared error}}   &73.\+0292 \%   &\\\cline{1-3}
{\bfseries{Total Number of Instances}}   &63   &\\\cline{1-3}
\end{longtabu}
\hypertarget{md_README_autotoc_md55}{}\doxysubsection{\texorpdfstring{{\bfseries{Video Demonstration}}}{{\bfseries{Video Demonstration}}}}\label{md_README_autotoc_md55}
The video demonstrates the values of the registers that are generated by the Machine Learning Core based on the header file that was included in the firmware.

{\bfseries{\mbox{[}Falling Detection with Machine Learning Core Sensor LSM6\+DSOX -\/ WL55\+JCx + Sensor\+Hub $|$$|$ ISCA Lab\mbox{]}(\href{https://www.youtube.com/watch?v=GsexEODn7TA}{\texttt{ https\+://www.\+youtube.\+com/watch?v=\+Gsex\+EODn7\+TA}}) \textbackslash{}\mbox{[}12\textbackslash{}\mbox{]}}}

\hypertarget{md_README_autotoc_md56}{}\doxysubsubsection{\texorpdfstring{Power Measurement}{Power Measurement}}\label{md_README_autotoc_md56}
   \hypertarget{md_README_autotoc_md57}{}\doxysection{\texorpdfstring{{\bfseries{References}}}{{\bfseries{References}}}}\label{md_README_autotoc_md57}

\begin{DoxyEnumerate}
\item \href{https://teicrete-my.sharepoint.com/personal/tp4591_edu_hmu_gr/Documents/B-L072Z-LRWAN1}{\texttt{ {\bfseries{B-\/\+L072\+Z-\/\+LRWAN1}}}}, \href{https://www.st.com/en/evaluation-tools/b-l072z-lrwan1.html}{\texttt{ https\+://www.\+st.\+com/en/evaluation-\/tools/b-\/l072z-\/lrwan1.\+html}}
\item \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+X-\/\+NUCLEO-\/\+IKS01\+A3\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}, \href{https://www.st.com/en/ecosystems/x-nucleo-iks01a3.html}{\texttt{ https\+://www.\+st.\+com/en/ecosystems/x-\/nucleo-\/iks01a3.\+html}}
\item \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+STEVAL-\/\+MKI197\+V1\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}, \href{https://www.st.com/en/evaluation-tools/steval-mki197v1.html}{\texttt{ https\+://www.\+st.\+com/en/evaluation-\/tools/steval-\/mki197v1.\+html}}
\item \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+I3\+C\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}, \href{https://en.wikipedia.org/wiki/I3C_(bus)}{\texttt{ https\+://en.\+wikipedia.\+org/wiki/\+I3\+C\+\_\+(bus)}}
\item \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+X-\/\+CUBE-\/\+MEMS1 Firmware Package\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*},
\end{DoxyEnumerate}

\href{https://github.com/STMicroelectronics/X-CUBE-MEMS1}{\texttt{ https\+://github.\+com/\+STMicroelectronics/\+X-\/\+CUBE-\/\+MEMS1}}


\begin{DoxyEnumerate}
\item \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+Unicleo-\/\+GUI\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}, \href{https://www.st.com/en/development-tools/unicleo-gui.html}{\texttt{ https\+://www.\+st.\+com/en/development-\/tools/unicleo-\/gui.\+html}}
\item \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+Unico-\/\+GUI\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}, \href{https://www.st.com/en/development-tools/unico-gui.html}{\texttt{ https\+://www.\+st.\+com/en/development-\/tools/unico-\/gui.\+html}}
\item \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+Weka\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}, \href{https://www.cs.waikato.ac.nz/ml/index.html}{\texttt{ https\+://www.\+cs.\+waikato.\+ac.\+nz/ml/index.\+html}}
\item \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+Unico’s Machine Learning Core User Guide\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*},
\end{DoxyEnumerate}

\href{https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=&ved=2ahUKEwiD8Jjfh5T6AhV-hf0HHevHC7AQFnoECB8QAQ&url=https\%3A\%2F\%2Fwww.st.com\%2Fresource\%2Fen\%2Fuser_manual\%2Fcd00297387-unico-gui-stmicroelectronics.pdf&usg=AOvVaw3QMf286kZJigIy6RPmtIM2}{\texttt{ https\+://www.\+google.\+com/url?sa=t\&rct=j\&q=\&esrc=s\&source=web\&cd=\&ved=2ah\+UKEwi\+D8\+Jjfh5\+T6\+Ah\+V-\/hf0\+HHev\+HC7\+AQFno\+ECB8\+QAQ\&url=https\%3\+A\%2\+F\%2\+Fwww.\+st.\+com\%2\+Fresource\%2\+Fen\%2\+Fuser\+\_\+manual\%2\+Fcd00297387-\/unico-\/gui-\/stmicroelectronics.\+pdf\&usg=\+AOv\+Vaw3\+QMf286k\+ZJig\+Iy6\+RPmt\+IM2}}


\begin{DoxyEnumerate}
\item \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+Machine Learning Core LSM6\+DSOX Demonstration \textbackslash{}\texorpdfstring{$\vert$}{|}\textbackslash{}\texorpdfstring{$\vert$}{|} ISCA Lab\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}, \href{https://www.youtube.com/watch?v=m6ylfVGBezo}{\texttt{ https\+://www.\+youtube.\+com/watch?v=m6ylf\+VGBezo}}
\item \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+Falling Detection with Machine Learning Core STM MEMS Sensor LSM6\+DSOX \textbackslash{}\texorpdfstring{$\vert$}{|}\textbackslash{}\texorpdfstring{$\vert$}{|} ISCA Lab\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}, \href{https://www.youtube.com/watch?v=tSlJXf_sjQc&feature=youtu.be}{\texttt{ https\+://www.\+youtube.\+com/watch?v=t\+Sl\+JXf\+\_\+sj\+Qc\&feature=youtu.\+be}}
\item {\bfseries{Falling Detection with Machine Learning Core Sensor LSM6\+DSOX -\/ WL55\+JCx + Sensor\+Hub $|$$|$ ISCA Lab,}} \href{https://www.youtube.com/watch?v=GsexEODn7TA}{\texttt{ https\+://www.\+youtube.\+com/watch?v=\+Gsex\+EODn7\+TA}} 
\end{DoxyEnumerate}